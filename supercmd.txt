#ifdef _CPU_CMDS_

CPU_CMD(PUSH, 1, 1, printf("push\n"); 
					bin_offset_ += 2 * sizeof(int);
					ip_++;
		)

CPU_CMD(JMP, 1, 2,	printf("jump\n");
					for (size_t i = 0; i < sizeof(int); i++)
						((char*)&type1_)[i] = bin_str_[bin_offset_ + i];
					bin_offset_ += sizeof(int);

					unsigned int addr = 0;
					for (size_t i = 0; i < sizeof(int); i++)
						((char*)&addr)[i] = bin_str_[bin_offset_ + i];
					bin_offset_ += sizeof(int);

					switch (type1_)
					{
						case TYPE_RGSR:
							ip_ = (size_t) registers_[addr];
							break;
						case TYPE_LABL:
							ip_ = addr;
							break;
						default:
							printf("CPU: Error: invalid arg type for 'JUMP' cmd\n");
							exit(EXIT_FAILURE);
					}
		)

CPU_CMD	(POP, 1, 3,	printf("pop\n");
					for (size_t i = 0; i < sizeof(int); i++)
						((char*)&type1_)[i] = bin_str_[bin_offset_ + i];
					bin_offset_ += sizeof(int);

					unsigned int addr = 0;
					for (size_t i = 0; i < sizeof(int); i++)
						((char*)&addr)[i] = bin_str_[bin_offset_ + i];
					bin_offset_ += sizeof(int);

					int errcode = 0;
					switch(type1_)
					{
						case TYPE_RGSR:
							registers_[addr] = stack_->Pop(&errcode);
							ip_++;
							break;
						default:
							printf("CPU: error: invalid arg type for cmd 'POP'\n");
							exit(EXIT_FAILURE);
					}
					ip_++;
		)

CPU_CMD	(ADD, 0, 4,	printf("add\n");
					bin_offset_ += sizeof(int);
					ip_++;
		)

CPU_CMD	(MUL, 0, 5, printf("mul\n");
					bin_offset_ += sizeof(int);
					ip_++;
		)

CPU_CMD	(SUB, 0, 6, printf("sub\n");
					ip_++;
		)

CPU_CMD(CALL, 1, 8, printf("call\n");
					for (size_t i = 0; i < sizeof(int); i++)
						((char*)&type1_)[i] = bin_str_[bin_offset_ + i];
					bin_offset_ += sizeof(int);

					unsigned int addr = 0;
					for (size_t i = 0; i < sizeof(int); i++)
						((char*)&addr)[i] = bin_str_[bin_offset_ + i];
					bin_offset_ += sizeof(int);
					
					ra_stack_->Push((double)ip_);
					switch (type1_)
					{
						case TYPE_RGSR:
							ip_ = (size_t) registers_[addr];
							break;
						case TYPE_LABL:
							ip_ = addr;
							break;
						default:
							printf("CPU: Error: invalid arg type for 'CALL' cmd\n");
							exit(EXIT_FAILURE);
					}
		)

CPU_CMD(OUTR, 1, 11,	printf("outr\n");
						for (size_t i = 0; i < sizeof(int); i++)
							((char*)&type1_)[i] = bin_str_[bin_offset_ + i];
						bin_offset_ += sizeof(int);

						if (type1_ != TYPE_RGSR)
						{
							printf("CPU: Error: invalid type for 'OUTR' cmd\n");
							exit(EXIT_FAILURE);
						}

						int reg_num = 0;
						for (size_t i = 0; i < sizeof(int); i++)
							((char*)&reg_num)[i] = bin_str_[bin_offset_ + i];

						bin_offset_ += sizeof(int);
						printf("R%d : %lg\n", reg_num, registers_[reg_num]);
						ip_++;
		)

CPU_CMD	(INR, 1, 12,	printf("inr\n");	
						int reg_num = 0;
						for (size_t i = 0; i < sizeof(int); i++)
							((char*)&reg_num)[i] = bin_str_[bin_offset_ + i];

						bin_offset_ += sizeof(int);
						if (scanf("%lg", &registers_[reg_num]) < 0)
						{
							printf("CPU: INR: Error reading\n");
							exit(EXIT_FAILURE);
						}
						ip_++;
		)

CPU_CMD	(RET, 1, 13, printf("ret\n");
					int errcode = 0;
					ip_ = (size_t) ra_stack_->Pop(&errcode);
					printf("CPU: Pop: errcode %d\n", errcode);
		)

#endif
